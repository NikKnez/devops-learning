# Labs 1-15

# Lab 1: Setup

## Setup Name and Email

If you have never used git before, you need to do some setup first. 
Run the following commands so that git knows your name and email. If you have git already setup, you can skip down to the line ending section.
Execute:

git config --global user.name "Your Name"

git config --global user.email "your_email@whatever.com"

## Setup Line Ending Preferences

Also, for Unix/Mac users:
Execute:

git config --global core.autocrlf input

git config --global core.safecrlf true

And for Windows users:
Execute:

git config --global core.autocrlf true

git config --global core.safecrlf true


# Lab 2: More Setup

## Get the Tutorial package

    Download from: https://gitimmersion.com/git_tutorial.zip

## Unzip the tutorial

The tutorial package should have a main directory “git_tutorial” with 
three sub-directories:

    html — These html files. Point your browser to html/index.html
    work — An empty working directory. Create your repos in here.
    repos — Prepackaged Git repositories so you can jump into the tutorial 
            at any point. 
            If you get stuck, just copy the desired lab 
            into your working directory.
 
## Lab 3: Create a Project

## Goals

    Learn how to create a git repository from scratch.

## Create a “Hello, World” program

Starting in the empty working directory, create an empty directory named “hello”, then create a file named hello.rb with the contents below.
Execute:

mkdir hello

cd hello

hello.rb

puts "Hello, World"

## Create the Repository

You now have a directory with a single file. To create a git repository from that directory, run the git init command.
Execute:

git init

Output:

$ git init
Initialized empty Git repository in /Users/jim/Downloads/git_tutorial/work/hello/.git/

## Add the program to the repository

Now let’s add the “Hello, World” program to the repository.
Execute:

git add hello.rb

git commit -m "First Commit"

You should see …
Output:

$ git add hello.rb
$ git commit -m "First Commit"
[main (root-commit) f7c41d3] First Commit
 1 file changed, 1 insertion(+)
 create mode 100644 hello.rb


## Lab 4: Checking Status

## Goals

    Learn how to check the status of the repository

## Check the status of the repository

Use the git status command to check the current status of the repository.
Execute:

git status

You should see
Output:

$ git status
On branch main
nothing to commit, working tree clean

The status command reports that there is nothing to commit. This means that the repository has all the current state of the working directory. There are no outstanding changes to record.

We will use the git status command to continue to monitor the state between the repository and the working directory.


## Lab 5: Making Changes

## Goals

    Learn how to monitor the state of the working directory

## Change the “Hello, World” program.

It’s time to change our hello program to take an argument from the command line. Change the file to be:
hello.rb

puts "Hello, #{ARGV.first}!"

## Check the status

Now check the status of the working directory.
Execute:

git status

You should see …
Output:

$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")

The first thing to notice is that git knows that the hello.rb file has been modified, but git has not yet been notified of these changes.

Also notice that the status message gives you hints about what you need to do next. If you want to add these changes to the repository, then use the git add command. Otherwise the git checkout command can be used to discard the changes.

## Up Next

Let’s stage the change.



## Lab 6: Staging Changes

## Goals

    Learn how to stage changes for later commits

## Add Changes

Now tell git to stage the changes. Check the status
Execute:

git add hello.rb

git status

You should see …
Output:

$ git add hello.rb
$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   hello.rb

The change to the hello.rb file has been staged. This means that git now knows about the change, but the change hasn’t been permanently recorded in the repository yet. The next commit operation will include the staged changes.

If you decide you don’t want to commit that change after all, the status command reminds you that the git restore command can be used to unstage that change.


## Lab 7: Staging and Commiting

A separate staging step in git is in line with the philosophy of getting out of the way until you need to deal with source control. You can continue to make changes to your working directory, and then at the point you want to interact with source control, git allows you to record your changes in small commits that record exactly what you did.

For example, suppose you edited three files (a.rb, b.rb, and c.rb). Now you want to commit all the changes, but you want the changes in a.rb and b.rb to be a single commit, while the changes to c.rb are not logically related to the first two files and should be a separate commit.

You could do the following:

git add a.rb

git add b.rb

git commit -m "Changes for a and b"

git add c.rb

git commit -m "Unrelated change to c"

By separating staging and committing, you have the ability to easily fine tune what goes into each commit.


## Lab 8: Commiting Changes

## Goals

    Learn how to commit changes to the repository

## Commit the change

Ok, enough about staging. Let’s commit what we have staged to the repository.

When you used git commit previously to commit the initial version of the hello.rb file to the repository, you included the -m flag that gave a comment on the command line. The commit command will allow you to interactively edit a comment for the commit. Let’s try that now.

If you omit the -m flag from the command line, git will pop you into the editor of your choice. The editor is chosen from the following list (in priority order):

    GIT_EDITOR environment variable
    core.editor configuration setting
    VISUAL environment variable
    EDITOR environment variable

I have the EDITOR variable set to emacsclient.

So commit now and check the status.
Execute:

git commit

You should see the following in your editor:
Output:

|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch main
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   hello.rb
#

On the first line, enter the comment: “Using ARGV”. Save the file and exit the editor. You should see …
Output:

git commit
Waiting for Emacs...
[main 569aa96] Using ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)

The “Waiting for Emacs…” line comes from the emacsclient program which sends the file to a running emacs program and waits for the file to be closed. The rest of the output is the standard commit messages.

## Check the status

Finally let’s check the status again.
Execute:

git status

You should see …
Output:

$ git status
On branch main
nothing to commit, working tree clean

The working directory is clean and ready for you to continue.



## Lab 9: Changes, not Files

## Goals

    Learn that git works with changes, not files.

Most source control systems work with files. You add a file to source control and the system will track changes to the file from that point on.

Git focuses on the changes to a file rather than the file itself. When you say git add file, you are not telling git to add the file to the repository. Rather you are saying that git should make note of the current state of that file to be committed later.

We will attempt to explore that difference in this lab.

## First Change: Allow a default name

Change the “Hello, World” program to have a default value if a command line argument is not supplied.
hello.rb

name = ARGV.first || "World"

puts "Hello, #{name}!"

## Add this Change

Now add this change to the git’s staging area.
Execute:

git add hello.rb

## Second change: Add a comment

Now add a comment to the “Hello, World” program.
hello.rb

# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"

## Check the current status
Execute:

git status

You should see …
Output:

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   hello.rb

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   hello.rb

Notice how hello.rb is listed twice in the status. The first change (adding a default) is staged and is ready to be committed. The second change (adding a comment) is unstaged. If you were to commit right now, the comment would not be saved in the repository.

Let’s try that.

## Committing

Commit the staged change (the default value), and then recheck the status.
Execute:

git commit -m "Added a default value"

git status

You should see …
Output:

$ git commit -m "Added a default value"
[main a6b268e] Added a default value
 1 file changed, 3 insertions(+), 1 deletion(-)
$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")

The status command is telling you that hello.rb has unrecorded changes, but is no longer in the staging area.

## Add the Second Change

Now add the second change to staging area, then run git status.
Execute:

git add .

git status

Note: We used the current directory (‘.’) as the file to add. This is a really convenient shortcut for adding in all the changes to the files in the current directory and below. But since it adds everything, it is a really good idea to check the status before doing an add ., just to make sure you don’t add any file that is not intended.

I wanted you to see the “add .” trick, but we will continue to add explicit files in the rest of this tutorial just to be safe.

You should see …
Output:

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   hello.rb

Now the second change has been staged and is ready to commit.

## Commit the Second Change
Execute:

git commit -m "Added a comment"



## Lab 10: History

## Goals

    Learn how to view the history of the project.

Getting a listing of what changes have been made is the function of the git log command.
Execute:

git log

You should see …
Output:

$ git log
commit e4e3645637546103e72f0deb9abdd22dd256601e
Author: Jim Weirich <jim (at) edgecase.com>
Date:   Sat Jun 10 03:49:13 2023 -0400

    Added a comment

commit a6b268ebc6a47068474bd6dfb638eb06896a6057
Author: Jim Weirich <jim (at) edgecase.com>
Date:   Sat Jun 10 03:49:13 2023 -0400

    Added a default value

commit 174dfabb62e6588c0e3c40867295da073204eb01
Author: Jim Weirich <jim (at) edgecase.com>
Date:   Sat Jun 10 03:49:13 2023 -0400

    Using ARGV

commit f7c41d3ce80ca44e2c586434cbf90fea3a9009a5
Author: Jim Weirich <jim (at) edgecase.com>
Date:   Sat Jun 10 03:49:13 2023 -0400

    First Commit

Here is a list of all four commits that we have made to the repository so far.

## One Line Histories

You have a great deal of control over exactly what the log command displays. I like the one line format:
Execute:

git log --pretty=oneline

You should see …
Output:

$ git log --pretty=oneline
e4e3645637546103e72f0deb9abdd22dd256601e Added a comment
a6b268ebc6a47068474bd6dfb638eb06896a6057 Added a default value
174dfabb62e6588c0e3c40867295da073204eb01 Using ARGV
f7c41d3ce80ca44e2c586434cbf90fea3a9009a5 First Commit

#3 Controlling Which Entries are Displayed

There are a lot of options for selecting which entries are displayed in the log. Play around with the following options:

git log --pretty=oneline --max-count=2

git log --pretty=oneline --since='5 minutes ago'

git log --pretty=oneline --until='5 minutes ago'

git log --pretty=oneline --author=<your name>

git log --pretty=oneline --all

See man git-log for all the details.

## Getting Fancy

Here’s what I use to review the changes made in the last week. I’ll add --author=jim if I only want to see changes I made.

git log --all --pretty=format:'%h %cd %s (%an)' --since='7 days ago'

## The Ultimate Log Format

Over time, I’ve decided that I like the following log format for most of my work.
Execute:

git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short

It looks like this:
Output:

$ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
* e4e3645 2023-06-10 | Added a comment (HEAD -> main) [Jim Weirich]
* a6b268e 2023-06-10 | Added a default value [Jim Weirich]
* 174dfab 2023-06-10 | Using ARGV [Jim Weirich]
* f7c41d3 2023-06-10 | First Commit [Jim Weirich]

Let’s look at it in detail:

    --pretty="..." defines the format of the output.
    %h is the abbreviated hash of the commit
    %d are any decorations on that commit (e.g. branch heads or tags)
    %ad is the author date
    %s is the comment
    %an is the author name
    --graph informs git to display the commit tree in an ASCII graph layout
    --date=short keeps the date format nice and short

This is a lot to type every time you want to see the log. Fortunately we will learn about git aliases in the next lab.

## Other Tools

Both gitx (for Macs) and gitk (any platform) are useful in exploring log history.



## Lab 11: Aliases

## Goals

    Learn how to setup aliases and shortcuts for git commands

## Common Aliases

git status, git add, git commit, and git checkout are such common commands that it is useful to have abbreviations for them.

Add the following to the .gitconfig file in your $HOME directory.
.gitconfig

[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short
  type = cat-file -t
  dump = cat-file -p

We’ve covered the commit and status commands already. And we just covered the log command in the previous lab. The checkout command will be coming up soon.

With these aliases defined in the .gitconfig file you can type git co wherever you used to have to type git checkout. Likewise with git st for git status and git ci for git commit. And best of all, git hist will allow you to avoid the really long log command.

Go ahead and give the new commands a try.

## Define the hist alias in your .gitconfig file

For the most part, I will continue to type out the full command in these instructions. The only exception is that I will use the hist alias defined above anytime we need to see the git log output. Make sure you have a hist alias setup in your .gitconfig file before continuing if you wish to follow along.

## Type and Dump

We’ve added a few aliases for commands we haven’t covered yet. The git branch command will be coming up soon. And the git cat-file command is useful for exploring git, which we will see in a little while.

## Shell Aliases (Optional)

Note: This section is for folks running a posix-like shell. Windows users and other non-posix shell users can feel free to skip to the next lab.

If your shell supports aliases or shortcuts, then you can add aliases at that level too. Here are the ones I use:
.profile

alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '

The gco abbreviation for git checkout is particularly nice. It allows me to type:

gco <branch>

to checkout a particular branch.

And yes, I do mistype git as get or got often enough to create aliases for them.



## Lab 12: Getting Old Versions

## Goals

    Learn how to checkout any previous snapshot into the working directory.

Going back in history is very easy. The checkout command will copy any snapshot from the repository to the working directory.

## Get the hashes for previous versions
Execute:

git hist

Note: You did remember to define hist in your .gitconfig file, right? If not, review the lab on aliases.
Output:

$ git hist
* e4e3645 2023-06-10 | Added a comment (HEAD -> main) [Jim Weirich]
* a6b268e 2023-06-10 | Added a default value [Jim Weirich]
* 174dfab 2023-06-10 | Using ARGV [Jim Weirich]
* f7c41d3 2023-06-10 | First Commit [Jim Weirich]

Examine the log output and find the hash for the first commit. It should be the last line of the git hist output. Use that hash code (the first 7 characters are enough) in the command below. Then check the contents of the hello.rb file.
Execute:

git checkout <hash>

cat hello.rb

Note: The commands given here are Unix commands and work on both Mac and Linux boxes. Unfortunately, Windows users will have to translate to their native commands.

Note: Many commands depend on the hash values in the repository. Since your hash values will vary from mine, whenever you see something like <hash> or <treehash> in the command, substitute in the proper hash value for your repository.

You should see …
Output:

$ git checkout f7c41d3
Note: switching to 'f7c41d3'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at f7c41d3 First Commit
$ cat hello.rb
puts "Hello, World"

The output of the checkout command explains the situation pretty well. Older versions of git will complain about not being on a local branch. In any case, don’t worry about that for now.

Notice the contents of the hello.rb file are the original contents.

## Return the latest version in the main branch
Execute:

git checkout main

cat hello.rb

You should see …
Output:

$ git checkout main
Previous HEAD position was f7c41d3 First Commit
Switched to branch 'main'
$ cat hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"

‘main’ is the name of the default branch. By checking out a branch by name, you go to the latest version of that branch.


## Lab 13: Tagging versions

## Goals

    Learn how to tag commits with names for future reference

Let’s call the current version of the hello program version 1 (v1).

## Tagging version 1
Execute:

git tag v1

Now you can refer to the current version of the program as v1.

## Tagging Previous Versions

Let’s tag the version immediately prior to the current version v1-beta. First we need to checkout the previous version. Rather than look up the hash, we will use the ^ notation to indicate “the parent of v1”.

If the v1^ notation gives you any trouble, you can also try v1~1, which will reference the same version. This notation means “the first ancestor of v1”.
Execute:

git checkout v1^

cat hello.rb

Output:

$ git checkout v1^
Note: switching to 'v1^'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at a6b268e Added a default value
$ cat hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"

See, this is the version with the default value before we added the comment. Let’s make this v1-beta.
Execute:

git tag v1-beta

## Checking Out by Tag Name

Now try going back and forth between the two tagged versions.
Execute:

git checkout v1

git checkout v1-beta

Output:

$ git checkout v1
Previous HEAD position was a6b268e Added a default value
HEAD is now at e4e3645 Added a comment
$ git checkout v1-beta
Previous HEAD position was e4e3645 Added a comment
HEAD is now at a6b268e Added a default value

## Viewing Tags using the tag command

You can see what tags are available using the git tag command.
Execute:

git tag

Output:

$ git tag
v1
v1-beta

## Viewing Tags in the Logs

You can also check for tags in the log.
Execute:

git hist main --all

Output:

$ git hist main --all
* e4e3645 2023-06-10 | Added a comment (tag: v1, main) [Jim Weirich]
* a6b268e 2023-06-10 | Added a default value (HEAD, tag: v1-beta) [Jim Weirich]
* 174dfab 2023-06-10 | Using ARGV [Jim Weirich]
* f7c41d3 2023-06-10 | First Commit [Jim Weirich]

You can see both tags (v1 and v1-beta) listed in the log output, along with the branch name (main). Also HEAD shows you the currently checked out commit (which is v1-beta at the moment).



## Lab 14: Undoing Local Changes (before staging)

## Goals

    Learn how to revert changes in the working directory

## Checkout main

Make sure you are on the latest commit in main before proceeding.
Execute:

git checkout main

## Change hello.rb

Sometimes you have modified a file in your local working directory and you wish to just revert to what has already been committed. The checkout command will handle that.

Change hello.rb to have a bad comment.
hello.rb

# This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"

## Check the Status

First, check the status of the working directory.
Execute:

git status

Output:

$ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   hello.rb

no changes added to commit (use "git add" and/or "git commit -a")

We see that the hello.rb file has been modified, but hasn’t been staged yet.

## Revert the changes in the working directory

Use the checkout command to checkout the repository’s version of the hello.rb file.
Execute:

git checkout hello.rb

git status

cat hello.rb

Output:

$ git checkout hello.rb
Updated 1 path from the index
$ git status
On branch main
nothing to commit, working tree clean
$ cat hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"

The status command shows us that there are no outstanding changes in the working directory. And the “bad comment” is no longer part of the file contents.



## Lab 15: Undoing Staged Changes (before committing)

## Goals

    Learn how to revert changes that have been staged

## Change the file and stage the change

Modify the hello.rb file to have a bad comment
hello.rb

# This is an unwanted but staged comment
name = ARGV.first || "World"

puts "Hello, #{name}!"

And then go ahead and stage it.
Execute:

git add hello.rb

## Check the Status

Check the status of your unwanted change.
Execute:

git status

Output:

$ git status
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   hello.rb

The status output shows that the change has been staged and is ready to be committed.

## Reset the Staging Area

The reset command resets the staging area to be whatever is in HEAD. This clears the staging area of the change we just staged.
Execute:

git reset HEAD hello.rb

Output:

$ git reset HEAD hello.rb
Unstaged changes after reset:
M	hello.rb

The reset command (by default) doesn’t change the working directory. So the working directory still has the unwanted comment in it. We can use the checkout command of the previous lab to remove the unwanted change from the working directory.

Note: You could also have used the git restore command to restore just the single file.

## Checkout the Committed Version
Execute:

git checkout hello.rb

git status

Output:

$ git status
On branch main
nothing to commit, working tree clean

And our working directory is clean once again.



